# Generated by https://quicktype.io

from datetime import datetime
from typing import List, Dict


class SchedulePeriod:
    start_date: datetime
    end_date: datetime
    change_date: datetime

    def __init__(self, start_date: datetime, end_date: datetime, change_date: datetime) -> None:
        self.start_date = start_date
        self.end_date = end_date
        self.change_date = change_date

class ScheduleDescription:
    id: int
    schedule_description_id: int
    name: str
    description: str
    typ_id:int
    color: str
    
    def __init__(self,id:int, schedule_description_id:int ,name:str ,description:str, typ_id:int,color:str) -> None:
        self.id=id
        self.schedule_description_id =schedule_description_id
        self.name = name
        self.description = description
        self.typ_id = typ_id
        self.color = color
    def __str__(self) -> str:
        return f"{self.name} - {self.schedule_description_id} - {self.id}"
    

class ScheduleDescriptions(ScheduleDescription):
    lista: dict

    def __init__(self, data) -> None:
        self.lista =[]
        self.readdata(data)

    def readdata(self,data):
        for ty in data:
            a=ScheduleDescription(ty["id"],ty["scheduleDescriptionId"],ty["name"],ty["description"],ty["description"],ty["color"])
            # print(a)
            self.addscheduledescription(a)        
            
    def addscheduledescription(self, scheduledescription: ScheduleDescription):
        if isinstance(scheduledescription, ScheduleDescription):
            self.lista.append(scheduledescription)
    
    def getScheduleDescriptions(self) -> dict:
        return self.lista
    
    def getscheduledescription(self, id) -> ScheduleDescription:
        for l in self.lista:
            if l.id==id:
                return l
  
            
    def __str__(self) -> str:
        return str(len(self.lista))
    
    
class Schedule(ScheduleDescription):
    id: int
    month: int
    days: str
    year: int
    schedule_description_id: int

    def __init__(self, id: int, month: int, days: str, year: int, schedule_description_id: int,scheduledescription: ScheduleDescription) -> None:
        self.id = id
        self.month = month
        self.days = days
        self.year = year
        self.schedule_description_id = schedule_description_id
        self.scheduledescription = scheduledescription
        
    def __str__(self) -> str:
        return f"{self.month}/{self.days}/{self.year} -> {self.scheduledescription.name}"
    def getcvs(self):
        print(f'{self.month}')
        if int(self.month) == 1:
            return [self.scheduledescription.name,str(f"{self.month}/{self.days}/{self.year}"),"04:00","true",self.scheduledescription.description]
        else:
            return None

class Schedules(Schedule):

    
    def __init__(self, startdate,enddate,changedate,data,scheduledescriptions: ScheduleDescriptions):
        self.startdate=startdate
        self.enddate=enddate
        self.changedate=changedate
        self.harmonogram=[]
        self.scheduledescriptions = scheduledescriptions
        self.readdata(data)
        
    def readdata(self,data):
        for ty in data:
            dni = ty["days"].split(";")
            for d in dni:
                a=Schedule(ty["id"],ty["month"],d,ty["year"],ty["scheduleDescriptionId"],self.scheduledescriptions.getscheduledescription(ty["scheduleDescriptionId"]))
                self.addschedule(a)    
  

    def addschedule(self,schedule: Schedule) -> None:
        if isinstance(schedule,Schedule):
            self.harmonogram.append(schedule)
    
    def getschedules(self) -> dict:
        return self.harmonogram

    def __str__(self) -> str:
        return str(len(self.harmonogram))
    


class Street:
    id: int
    name: str
    region: str
    numbers: str
    number_from: str
    number_to: str
    sides: str
    stamp: str

    def __init__(self, id: int, name: str, region: str, numbers: str, number_from: str, number_to: str, sides: str, stamp: str) -> None:
        self.id = id
        self.name = name
        self.region = region
        self.numbers = numbers
        self.number_from = number_from
        self.number_to = number_to
        self.sides = sides
        self.stamp = stamp


class Town:
    name: str
    district: str
    province: str

    def __init__(self, name: str, district: str, province: str) -> None:
        self.name = name
        self.district = district
        self.province = province


class TopLevel:
    schedules: List[Schedule]
    schedule_description: List[Dict[str, str]]
    street: Street
    town: Town
    schedule_period: SchedulePeriod
    name: str
    id: int
    groupname: str
    groupdescription: str


    def __init__(self, schedules: List[Schedule], schedule_description: List[Dict[str, str]], street: Street, town: Town, schedule_period: SchedulePeriod, name: str, id: int, groupname: str, groupdescription: str) -> None:
        self.schedules = schedules
        self.schedule_description = schedule_description
        self.street = street
        self.town = town
        self.schedule_period = schedule_period
        self.name = name
        self.id = id
        self.groupname = groupname
        self.groupdescription = groupdescription


class Dict2Object:
    """
    @DynamicAttrs
    Class to transform a dict into a python object.
    """

    def __init__(self, in_dict: dict):
        # type checking
        assert isinstance(in_dict, dict)
        # iterate over dict
        for key, val in in_dict.items():
            # translate the string to not have white spaces, dashes and be lower case etc
            key = translate_string(key)
            # check if the value is a (tuple, list, set)
            if isinstance(val, (list, tuple, set)):
                # set an attribute for every item in the Sequence
                # if the value is a dict, use the Dict2Object class (recursive)
                setattr(
                    self,
                    key,
                    [Dict2Object(x) if isinstance(x, dict) else x for x in val],
                )
            else:
                # if the value is not a (tuple, list, set)
                # set an attribute for the value unless
                # the value is a dict -> use the Dict2Object class (recursive)
                setattr(self, key, Dict2Object(val) if isinstance(val, dict) else val)

    def __repr__(self):
        return "{%s}" % str(
            ", ".join("'%s': %s" % (k, repr(v)) for (k, v) in self.__dict__.items())
        )


def translate_string(string: str) -> str:
    string = string.replace("-", "_")
    string = string.replace(" ", "_")
    string = string.lower()
    return string